import streamlit as st
import pandas as pd
from st_aggrid import AgGrid, GridOptionsBuilder
import requests
import PyPDF2
import json
import pandas as pd
import time
from functions import Agent, get_current_id, EmbeddingAgent, Client, RelationalClient


#### 19-02-2025 ####
from pydantic import ValidationError
from typing import Optional
from pydantic import BaseModel, Field

class CVData(BaseModel):
    Nombre: str = Field("No especificado", alias="Nombre")
    Ciudad: str = Field("No especificado", alias="Ciudad")
    Pa√≠s: str = Field("No especificado", alias="Pa√≠s")
    Fecha_de_Nacimiento: str = Field("No especificado", alias="Fecha de Nacimiento")
    Carrera: str = Field("No especificado", alias="Carrera")
    N√∫mero_de_Tel√©fono: str = Field("No especificado", alias="N√∫mero de Tel√©fono")
    Correo: str = Field("No especificado", alias="Correo")
    Entidad_Donde_Estudi√≥: str = Field("No especificado", alias="Entidad Donde Estudi√≥")
    Resumen_del_Postulante: str = Field("No especificado", alias="Resumen del Postulante")
    RUN: str = Field("No especificado", alias = "RUN del postulante")

    class Config:
        extra = "ignore"
        allow_population_by_field_name = True
#### 19-02-2025 ####




# Instanciamos los objetos necesarios
embed_agent = EmbeddingAgent()
client = Client()
relational_client = RelationalClient()

def read_file(file):
    """
    Lee un PDF (ya sea ruta local o un objeto de Streamlit) y devuelve todo el texto.
    """
    text = ""
    reader = PyPDF2.PdfReader(file)
    for page in reader.pages:
        text += page.extract_text() + "\n"
    return text

def limpiar_output(json_str):
    """
    Limpia el string JSON que regresa el modelo para poder parsearlo correctamente.
    """
    json_str = json_str.strip('```')  
    json_str = json_str.replace('json', '')  
    return json_str.strip()


#### 19-02-2025 ####
## Descomentar la funci√≥n si no corre el c√≥digo
# def process_pdf(pdf_text, prompt):
#     """
#     Recibe el texto de un PDF y un prompt, llama a la clase Agent,
#     interpreta la respuesta como JSON y la devuelve en un DataFrame.
#     """
#     user_prompt = prompt + f'{pdf_text}'
#     agent = Agent(user_prompt)
#     output = agent.getResp()

#     output = limpiar_output(output)
#     output = json.loads(output)

#     # Creamos un DataFrame con una sola fila
#     df = pd.DataFrame([output])
#     return df

def process_pdf(pdf_text, prompt):
    """
    Recibe el texto de un PDF y un prompt, llama a la clase Agent,
    interpreta la respuesta como JSON y la devuelve en un DataFrame.
    """
    user_prompt = prompt + f"{pdf_text}"
    agent = Agent(user_prompt)
    raw_output = agent.getResp()

    # Primero limpiamos el output de backticks y palabras sueltas:
    raw_output = limpiar_output(raw_output)

    # Intentamos aislar solo la parte JSON (en caso de que el modelo
    # haya agregado texto extra o disclaimers antes/despu√©s).
    if not raw_output.strip().startswith("{") or not raw_output.strip().endswith("}"):
        first_brace_index = raw_output.find("{")
        last_brace_index = raw_output.rfind("}")
        if first_brace_index == -1 or last_brace_index == -1:
            raise ValueError(
                f"No se encontr√≥ JSON v√°lido en la respuesta del modelo.\n\nRespuesta completa:\n{raw_output}"
            )
        # Extraemos √∫nicamente el contenido entre las primeras y √∫ltimas llaves.
        raw_output = raw_output[first_brace_index:last_brace_index+1]

    # Ahora parseamos con Pydantic para asegurarnos de que cumpla la estructura
    try:
        cv_data = CVData.parse_raw(raw_output)
    except ValidationError as ve:
        # Puede fallar porque falta un campo o porque la estructura no coincide.
        raise ValueError(f"El modelo no devolvi√≥ JSON v√°lido o faltan campos: {ve}\n\nRespuesta:\n{raw_output}")
    except json.JSONDecodeError as je:
        # Ocurre si la cadena no es parseable como JSON.
        raise ValueError(f"No se pudo decodificar el JSON: {je}\n\nRespuesta:\n{raw_output}")

    # Convertimos el objeto Pydantic a diccionario y luego a DataFrame
    data_dict = cv_data.dict(by_alias=True)
    df = pd.DataFrame([data_dict])
    return df
#### 19-02-2025 ####

import streamlit as st
import pandas as pd
from st_aggrid import AgGrid, GridOptionsBuilder
import requests
import PyPDF2
import json
import time
from functions import Agent, get_current_id, EmbeddingAgent, Client, RelationalClient

from pydantic import ValidationError
from typing import Optional
from pydantic import BaseModel, Field

class CVData(BaseModel):
    Nombre: str = Field("No especificado", alias="Nombre")
    Ciudad: str = Field("No especificado", alias="Ciudad")
    Pa√≠s: str = Field("No especificado", alias="Pa√≠s")
    Fecha_de_Nacimiento: str = Field("No especificado", alias="Fecha de Nacimiento")
    Carrera: str = Field("No especificado", alias="Carrera")
    N√∫mero_de_Tel√©fono: str = Field("No especificado", alias="N√∫mero de Tel√©fono")
    Correo: str = Field("No especificado", alias="Correo")
    Entidad_Donde_Estudi√≥: str = Field("No especificado", alias="Entidad Donde Estudi√≥")
    Resumen_del_Postulante: str = Field("No especificado", alias="Resumen del Postulante")
    RUN: str = Field("No especificado", alias="RUN del postulante")

    class Config:
        extra = "ignore"
        allow_population_by_field_name = True

# Instanciamos los objetos necesarios
embed_agent = EmbeddingAgent()
client = Client()
relational_client = RelationalClient()

def read_file(file):
    """
    Lee un PDF (ya sea ruta local o un objeto de Streamlit) y devuelve todo el texto.
    """
    text = ""
    reader = PyPDF2.PdfReader(file)
    for page in reader.pages:
        text += page.extract_text() + "\n"
    return text

def limpiar_output(json_str):
    """
    Limpia el string JSON que regresa el modelo para poder parsearlo correctamente.
    """
    json_str = json_str.strip('```')
    json_str = json_str.replace('json', '')
    return json_str.strip()

def process_pdf(pdf_text, prompt):
    """
    Recibe el texto de un PDF y un prompt, llama a la clase Agent,
    interpreta la respuesta como JSON y la devuelve en un DataFrame.
    """
    user_prompt = prompt + f"{pdf_text}"
    agent = Agent(user_prompt)
    raw_output = agent.getResp()

    # Primero limpiamos el output de backticks y palabras sueltas:
    raw_output = limpiar_output(raw_output)

    # Intentamos aislar solo la parte JSON
    if not raw_output.strip().startswith("{") or not raw_output.strip().endswith("}"):
        first_brace_index = raw_output.find("{")
        last_brace_index = raw_output.rfind("}")
        if first_brace_index == -1 or last_brace_index == -1:
            raise ValueError(
                f"No se encontr√≥ JSON v√°lido en la respuesta del modelo.\n\nRespuesta completa:\n{raw_output}"
            )
        raw_output = raw_output[first_brace_index:last_brace_index+1]

    try:
        cv_data = CVData.parse_raw(raw_output)
    except ValidationError as ve:
        raise ValueError(f"El modelo no devolvi√≥ JSON v√°lido o faltan campos: {ve}\n\nRespuesta:\n{raw_output}")
    except json.JSONDecodeError as je:
        raise ValueError(f"No se pudo decodificar el JSON: {je}\n\nRespuesta:\n{raw_output}")

    data_dict = cv_data.dict(by_alias=True)
    df = pd.DataFrame([data_dict])
    return df

def main():
    st.set_page_config(
        page_title="Caza Talentos: Encontrar al Candidato Ideal",
        page_icon=":mag_right:",
        layout="centered"
    )

    st.title("Caza Talentos: Encontrar al Candidato Ideal")
    st.markdown(
        """
        Bienvenido a la herramienta de **gesti√≥n de CVs**. 
        Aqu√≠ puedes subir curr√≠culums en PDF, extraer datos relevantes, 
        almacenarlos y consultarlos en una base de datos, y realizar b√∫squedas espec√≠ficas.
        """
    )
    st.divider()

    # Se crean las tres pesta√±as
    tab1, tab2, tab3 = st.tabs(["üìÅ Cargar PDF", "üí¨ Chat", "üìä Tabla"])

    # ------------------
    # Pesta√±a 1: Cargar PDF
    # ------------------
    with tab1:
        prompt = """
        A continuaci√≥n ver√°s un curr√≠culum vitae. 
        Extrae los siguientes campos y devu√©lvelos √öNICAMENTE en formato JSON v√°lido: 
        {
          "Nombre": "...",
          "Ciudad": "...",
          "Pa√≠s": "...",
          "Fecha de Nacimiento": "...",
          "Carrera": "...",
          "N√∫mero de Tel√©fono": "...",
          "Correo": "...",
          "Entidad Donde Estudi√≥": "...",
          "Resumen del Postulante": "...",
          "RUN del postulante": ""
        }
        
        No incluyas texto adicional, ni bloques de c√≥digo. 
        Curr√≠culum:
        """

        st.subheader("Subir y Procesar PDF")
        st.write(
            """
            Sube uno o m√°s archivos PDF. Se extraer√°n los datos y se mostrar√°n en un DataFrame editable.
            Cuando est√©s conforme, haz clic en "**Subir a la base de datos**" para guardar la informaci√≥n.
            """
        )

        uploaded_files = st.file_uploader(
            "Arrastra o haz clic para subir PDFs",
            type=["pdf"], 
            accept_multiple_files=True
        )

        if uploaded_files:
            all_dfs = []
            for pdf_file in uploaded_files:
                pdf_text = read_file(pdf_file)
                if not pdf_text.strip():
                    st.warning(f"El archivo '{pdf_file.name}' no contiene texto y ser√° omitido.")
                    continue
                df = process_pdf(pdf_text, prompt)
                all_dfs.append(df)

            if all_dfs:
                final_df = pd.concat(all_dfs, ignore_index=True)
                st.markdown("### Vista previa del DataFrame editable")
                
                # Guardamos el DataFrame en el estado de sesi√≥n la primera vez
                if "editable_df" not in st.session_state:
                    st.session_state.editable_df = final_df.copy()
                
                # Mostrar el DataFrame editable con AgGrid
                gb = GridOptionsBuilder.from_dataframe(st.session_state.editable_df)
                gb.configure_default_column(editable=True)
                gridOptions = gb.build()
                grid_response = AgGrid(
                    st.session_state.editable_df,
                    gridOptions=gridOptions,
                    update_mode="MODEL_CHANGED",
                    theme="blue"
                )
                # Actualizamos el DataFrame editable seg√∫n las ediciones
                st.session_state.editable_df = pd.DataFrame(grid_response["data"])
                
                if st.button("Subir a la base de datos"):
                    def valid_run(x):
                        x_str = str(x).strip().lower()
                        return x_str != "" and x_str != "no especificado"
                    
                    mask = st.session_state.editable_df["RUN del postulante"].apply(valid_run)
                    valid_rows = st.session_state.editable_df[mask]
                    invalid_rows = st.session_state.editable_df[~mask]
                    
                    if not valid_rows.empty:
                        try:
                            with st.spinner("Subiendo datos..."):
                                relational_client.insert_to_db(valid_rows)
                            st.success("¬°Datos subidos correctamente!")
                            # Actualizamos el DataFrame en el estado de sesi√≥n para conservar solo las filas sin RUN v√°lido
                            st.session_state.editable_df = invalid_rows.copy()
                        except Exception as e:
                            st.error(f"Error al subir a la base de datos: {e}")
                    else:
                        st.info("No hay filas con un RUN v√°lido para subir.")
            else:
                st.info("No se procesaron archivos v√°lidos para mostrar vista previa.")
        else:
            st.info("Por favor, sube al menos un archivo PDF.")

    # ------------------
    # Pesta√±a 2: Chat
    # ------------------
    with tab2:
        st.subheader("Chat de B√∫squeda y Prueba")
        st.write(
            """
            Aqu√≠ puedes realizar **b√∫squedas** en el sistema vectorial (Milvus). 
            Por ejemplo, escribe algo como "busco un desarrollador con experiencia en Python" 
            y ver√°s los resultados m√°s relacionados con ese texto.
            """
        )
        # Inicializar el historial del chat en el estado de sesi√≥n
        if "chat_history" not in st.session_state:
            st.session_state.chat_history = []
        
        st.markdown("### Historial del Chat")
        for chat in st.session_state.chat_history:
            st.markdown(f"**{chat['sender']}**: {chat['message']}")
        
        user_input = st.text_input("Pregunta o consulta:", placeholder="Ejemplo: 'Busco un ingeniero en Chile'")
    
        if st.button("Enviar Consulta"):
            if user_input.strip():
                with st.spinner("Consultando..."):
                    r = client.question(user_input)
                st.session_state.chat_history.append({"sender": "Usuario", "message": user_input})
                st.session_state.chat_history.append({"sender": "Bot", "message": r})
            else:
                st.warning("Por favor, escribe un mensaje antes de enviar.")

    # ------------------
    # Pesta√±a 3: Tabla
    # ------------------
    with tab3:
        st.subheader("Tabla de Candidatos")
        st.write(
            """
            A continuaci√≥n, se muestra la informaci√≥n actual de la base de datos relacional.
            """
        )

        try:
            with st.spinner("Cargando datos desde la base de datos..."):
                to_show = relational_client.getAllCandidates()
                st.dataframe(to_show, use_container_width=True)
        except Exception as e:
            st.error(f"No se pudo cargar la tabla de candidatos: {e}")

        st.divider()

main()

